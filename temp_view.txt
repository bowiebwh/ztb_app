from datetime import datetime
import json
import logging
from fastapi import APIRouter, Depends, HTTPException
from sqlalchemy.orm import Session
from database import SessionLocal
from models import GenerationTask, Project, FileRecord, TenderAnalysis as TenderAnalysisModel
from schemas import GenerationTaskCreate, GenerationTaskRead
from .export import export_word
from .analysis import _call_llm

router = APIRouter()
logger = logging.getLogger(__name__)


def get_db():
    db = SessionLocal()
    try:
        yield db
    finally:
        db.close()


def to_read_model(task: GenerationTask) -> GenerationTaskRead:
    return GenerationTaskRead(
        taskId=task.id,
        projectId=task.project_id,
        status=task.status,
        progress=task.progress,
        currentStage=task.current_stage,
        statusMessage=task.status_message,
        resultUrl=task.result_url,
        errorMessage=task.error_message,
        configId=task.config_id,
        startTime=task.started_at,
        updateTime=task.updated_at,
    )


def _build_section_prompt(project_name: str, summary: str, chapter: dict) -> str:
    title = chapter.get("title") or chapter.get("heading") or "ç« èŠ‚"
    sections = chapter.get("sections") or []
    sections_text = "\n".join([f"- {s}" for s in sections if s])
    return f"""ä½ æ˜¯ä¸€åä¸“ä¸šçš„æŠ•æ ‡ä¹¦æ’°å†™ä¸“å®¶ï¼Œè¯·ç”¨ä¸­æ–‡ç”Ÿæˆæœ¬ç« èŠ‚çš„æ­£æ–‡ã€?<é¡¹ç›®åç§°>
{project_name}
</é¡¹ç›®åç§°>
<ç« èŠ‚æ ‡é¢˜>
{title}
</ç« èŠ‚æ ‡é¢˜>
<å°èŠ‚è¦ç‚¹/å ä½ç¬?
{sections_text or "æ—?}
</å°èŠ‚è¦ç‚¹/å ä½ç¬?
<é¡¹ç›®æ‘˜è¦>
{summary}
</é¡¹ç›®æ‘˜è¦>

è¦æ±‚ï¼?- è¾“å‡ºçº¯ä¸­æ–‡æ­£æ–‡ï¼Œå¯åŒ…å«å ä½ç¬¦ï¼ˆä¾‹å¦?{{material:company_intro}}ï¼‰ï¼Œä¸å¯åˆ é™¤å ä½ç¬¦ã€?- ä¸è¦ä½¿ç”¨ Markdown ä»£ç å—æˆ–åˆ—è¡¨æ ‡è®°ï¼Œç›´æ¥è¾“å‡ºæ®µè½æ–‡æœ¬ã€?- å­—æ•°å»ºè®® 500-1000 å­—ï¼Œå†…å®¹ä¸“ä¸šã€è¿è´¯ã€?"""


def _generate_section_content(project_name: str, summary: str, chapter: dict) -> str:
    prompt = _build_section_prompt(project_name, summary, chapter)
    resp = _call_llm(prompt)
    return str(resp).strip()


@router.post("/{project_id}", response_model=GenerationTaskRead)
def start_generation(
    project_id: int, payload: GenerationTaskCreate = None, db: Session = Depends(get_db)
):
    project = db.query(Project).filter(Project.id == project_id).first()
    if not project:
        raise HTTPException(status_code=404, detail="Project not found")

    # å–æœ€æ–°çš„åˆ†æç»“æœï¼Œä½œä¸ºç”ŸæˆæŠ•æ ‡ä¹¦çš„å†…å®¹æ¥æº?    analysis = (
        db.query(TenderAnalysisModel)
        .filter(TenderAnalysisModel.project_id == project_id)
        .order_by(TenderAnalysisModel.updated_at.desc())
        .first()
    )
    if not analysis:
        raise HTTPException(status_code=400, detail="è¯·å…ˆå®Œæˆæ‹›æ ‡å†…å®¹è§£æåå†ç”ŸæˆæŠ•æ ‡ä¹?)

    summary = analysis.summary or ""
    doc_struct = json.loads(analysis.document_structure_json or "[]")

    def build_sections_with_generation(struct, summary_text: str) -> list[dict]:
        sections = []
        for ch in struct or []:
            heading = ch.get("title") or ch.get("heading") or "ç« èŠ‚"
            try:
                body_text = _generate_section_content(project.name, summary_text, ch)
            except HTTPException:
                raise
            except Exception as exc:
                logger.exception("ç”Ÿæˆç« èŠ‚å¤±è´¥ | project_id=%s heading=%s", project_id, heading)
                raise HTTPException(status_code=502, detail=f"ç”Ÿæˆç« èŠ‚å†…å®¹å¤±è´¥: {exc}")
            sections.append({"heading": heading, "level": 1, "body": body_text})
        if not sections and summary_text:
            sections.append({"heading": "æ¦‚è¦", "level": 1, "body": summary_text})
        return sections

    generated_sections = build_sections_with_generation(doc_struct, summary)
    full_content = "\n\n".join([f"{sec['heading']}\n{sec['body']}" for sec in generated_sections])

    title = f"{project.name} æŠ•æ ‡ä¹?
    filename = f"{project.name}.docx"
    payload_export = {
        "title": title,
        "subtitle": f"é¡¹ç›®ç¼–å·ï¼š{project.id}",
        "sections": generated_sections,
        "content": full_content,
        "filename": filename,
    }

    try:
        export_res = export_word(payload_export)
        logger.info(
            "Export word done for project %s | object=%s filename=%s",
            project_id,
            export_res.get("object_name"),
            export_res.get("filename"),
        )
    except HTTPException:
        raise
    except Exception as exc:
        logger.exception("Export word failed | project_id=%s", project_id)
        raise HTTPException(status_code=500, detail=f"ç”ŸæˆæŠ•æ ‡ä¹¦å¤±è´? {exc}")

    object_name = export_res.get("object_name")
    filename = export_res.get("filename") or f"{title}.docx"
    result_url = None

    # è®°å½•ç”Ÿæˆæ–‡ä»¶åˆ?FileRecordï¼Œä¾¿äºå‰ç«¯åˆ—è¡?ä¸‹è½½
    if object_name:
        file_record = FileRecord(
            project_id=project_id,
            filename=filename,
            object_name=object_name,
            content_type="application/vnd.openxmlformats-officedocument.wordprocessingml.document",
        )
        db.add(file_record)
        db.commit()
        db.refresh(file_record)
        result_url = f"/api/files/{file_record.id}/download"
        logger.info("Stored generated doc | project_id=%s file_id=%s object=%s url=%s", project_id, file_record.id, object_name, result_url)

    task = GenerationTask(
        project_id=project_id,
        status="Completed",
        progress=100.0,
        current_stage="Completed",
        status_message="ç”Ÿæˆå®Œæˆ",
        result_url=result_url,
        config_id=payload.config_id if payload else None,
        started_at=datetime.utcnow(),
        updated_at=datetime.utcnow(),
    )
    project.status = "Completed"

    project.updated_at = datetime.utcnow()
    db.add(task)
    db.add(project)
    db.commit()
    db.refresh(task)
    return to_read_model(task)


@router.get("/{project_id}/latest", response_model=GenerationTaskRead)
def get_latest_task(project_id: int, db: Session = Depends(get_db)):
    task = (
        db.query(GenerationTask)
        .filter(GenerationTask.project_id == project_id)
        .order_by(GenerationTask.updated_at.desc())
        .first()
    )
    if not task:
        raise HTTPException(statuscode=404, detail="Task not found")
    return to_read_model(task)


@router.get("/{project_id}/history", response_model=list[GenerationTaskRead])
def get_history(project_id: int, db: Session = Depends(get_db)):
    tasks = (
        db.query(GenerationTask)
        .filter(GenerationTask.project_id == project_id)
        .order_by(GenerationTask.updated_at.desc())
        .all()
    )
    return [to_read_model(t) for t in tasks]


@router.get("/{project_id}/{task_id}", response_model=GenerationTaskRead)
def get_task(project_id: int, task_id: int, db: Session = Depends(get_db)):
    task = (
        db.query(GenerationTask)
        .filter(GenerationTask.project_id == project_id, GenerationTask.id == task_id)
        .first()
    )
    if not task:
        raise HTTPException(status_code=404, detail="Task not found")
    return to_read_model(task)


@router.post("/{project_id}/{task_id}/complete", response_model=GenerationTaskRead)
def complete_task(project_id: int, task_id: int, db: Session = Depends(get_db)):
    task = (
        db.query(GenerationTask)
        .filter(GenerationTask.project_id == project_id, GenerationTask.id == task_id)
        .first()
    )
    if not task:
        raise HTTPException(status_code=404, detail="Task not found")

    task.status = "Completed"
    task.progress = 100.0
    task.current_stage = "Rendering"
    task.status_message = "ç”Ÿæˆå®Œæˆ"
    task.result_url = task.result_url or f"/api/files/download_case_study_word"
    task.updated_at = datetime.utcnow()

    project = db.query(Project).filter(Project.id == project_id).first()
    if project:
        project.status = "Completed"
        project.updated_at = datetime.utcnow()
        db.add(project)

    db.add(task)
    db.commit()
    db.refresh(task)
    return to_read_model(task)

